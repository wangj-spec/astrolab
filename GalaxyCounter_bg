from astropy.io import fits
import numpy as np
import matplotlib.pyplot as plt
from scipy.optimize import curve_fit
import numpy.ma as ma
from astropy.wcs import WCS
import scipy as sp

def findradiusandmask(array, coordinate, cutoff=0):
    """
    finds radius of galaxy and masks
    :param array: 2D array of data
    :param coordinate: tuple of form (x,y) x,y indices of array
    :param cutoff: value at which you decide a pixel is background noise
    :return: returns an array containing the pixel values within the galaxy, and the coordinates making
            up the circle of the galaxy
    """
    x = coordinate[0]
    y = coordinate[1]
    arraydata = ma.getdata(array)
    values = []
    where = []
    bg_vals = []
    flux = 0  # initialise a flux value
    i = 1  # initialise i for the loop

    while True:  # radius finding

        if array.shape[0] > y + i:
            if array[y + i][x] > cutoff:
                i += 1  # keep going outwards if value greater than cutoff value
            else:
                radius = i - 1  # stop at threshold and record radius of values
                rad_bg = i + 1

                break

        else:  # if scanning up gets out of bounds, scan downwards (for galaxies on edge of images)
            if array[y - i][x] > cutoff:
                i += 1  # keep going outwards if value greater than cutoff value
            else:
                radius = i - 1  # stop at threshold and record radius of values
                rad_bg = i + 1

                break
    print(radius)
    if radius > 2:  # Ensuring we only count the galaxy if it has a radius larger than 2, as a lower radius likely indicates noise.

        raditer = rad_bg  # initialise a radius value to iterate over
        while raditer >= (-1) * rad_bg:  # circle finding, loop over x and y coords

            xi = raditer  # initialise xi as distance along axis relative to x
            yi = int(np.sqrt(rad_bg ** 2 - raditer ** 2))  # initialise yi as maximum "height" within circle

            while rad_bg ** 2 >= xi ** 2 + yi ** 2:  # scan downwards along y axis at x = x+xi, mask at each point

                if array.shape[0] > y + yi and array.shape[1] > x + xi and radius ** 2 >= xi ** 2 + yi ** 2:

                    values.append(array[y + yi][x + xi])
                    where.append((x + xi, y + yi))
                    array = mask_value(array, (y + yi, x + xi))
                    flux += arraydata[y + yi][x + xi]  # sums even if there's an overlap with another galaxy (for ease
                    yi -= 1

                elif radius ** 2 < xi ** 2 + yi ** 2 and array.shape[0] > y + yi and array.shape[1] > x + xi:

                    bg_vals.append(arraydata[y + yi][x + xi])
                    # array = mask_value(array, (y+yi,x+xi))
                    yi -= 1

                else:  # If out of bounds, keep scanning downwards
                    yi -= 1

            raditer -= 1

        return values, where, flux, bg_vals, array

    elif radius <= 2:  # mask out all galaxies with a radius smaller than or equal to 2

        raditer = radius  # initialise a radius value to iterate over

        while raditer >= radius * (-1):  # circle finding, loop over x and y coords

            xi = raditer  # initialise xi as distance along axis relative to x
            yi = int(np.sqrt(radius ** 2 - raditer ** 2))  # initialise yi as maximum "height" within circle

            while radius ** 2 >= xi ** 2 + yi ** 2:  # scan downwards along y axis at x = x+xi, mask at each point

                if array.shape[0] > y + yi and array.shape[1] > x + xi:
                    array = mask_value(array, (y + yi, x + xi))
                    yi -= 1
                else:
                    yi -= 1

            raditer -= 1

        return None, None, None, None, array


def var_aperture(array, source_lim, rad_lim, centered=False):
    """
    find brightest pixel values down to n, for each pixel value finds a "circular" region of light
    and masks the entire region which i will call a galaxy
    :param array: 2d array to be analysed
    :param n: cutoff value below which a pixel is not counted as a source
    :param m: cutoff value below which a pixel is counted as background
    :param centered: return the center coordinates of the galaxy

    :return: max_vals: 2d array containing pixel values of each galaxy
             where: 2d array containing tuples containing coordinates in (x,y) indices of each pixel in each galaxy
             fluxes: 1d array containing summed flux values of each galaxy
    """
    i = True
    max_vals = []
    fluxes = []
    centers = []  # measure the center of each galaxy
    where = []  # coordinates of pixels in each galaxy
    while i:
        maxval = np.amax(array)
        print(maxval)
        if maxval <= source_lim:
            break

        else:
            where1 = np.argmax(array)  # returns index in flattened arraycopy for first occurrence of maxval
            where2 = np.unravel_index(where1, array.shape)  # back to a 2d coord
            print(where2)

            values, where3, lightsum, bg_values, array = findradiusandmask(array, (where2[1], where2[0]), rad_lim)

            if values == None:
                continue

            else:
                bg_av = np.mean(bg_values)
                values = [e - bg_av for e in values]

                fluxes.append(lightsum - len(values) * bg_av)
                centers.append(where2)
                where.append(where3)
                max_vals.append(values)
    fluxes.sort()
    if centered == False:
        return max_vals, where, fluxes, array

    else:
        return max_vals, where, fluxes, centers, array
