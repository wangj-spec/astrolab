from astropy.io import fits
import numpy as np
import matplotlib.pyplot as plt
from scipy.optimize import curve_fit
import numpy.ma as ma
from astropy.wcs import WCS
import scipy as sp

def findradiusandmask(array, coordinate, cutoff=0):
    """
    finds radius of galaxy and masks
    :param array: 2D array of data
    :param coordinate: tuple of form (x,y) x,y indices of array
    :param cutoff: value at which you decide a pixel is background noise
    :return: returns an array containing the pixel values within the galaxy, and the coordinates making
            up the circle of the galaxy
    """
    x = coordinate[0]
    y = coordinate[1]
    mask = ma.getmask(array)
    arraydata = ma.getdata(array)
    values = []
    where = []
    bg_vals = []
    flux = 0  # initialise a flux value
    i = 1  # initialise i for the loop
    if array[y][x] > 5000:
        radlim = 50
    else:
        radlim = 30

    while True:  # radius finding
        if array.shape[0] > y + i:
            if array[y + i][x] > cutoff:
                if i <= radlim:
                   i += 1  # keep going outwards if value greater than cutoff value
                else:
                    radius = 7
                    rad_bg = 9
                    break
            else:
                radius = i - 1  # stop at threshold and record radius of values
                rad_bg = i + 1

                break

        else:  # if scanning up gets out of bounds, scan downwards (for galaxies on edge of images)
            if array[y - i][x] > cutoff:
                i += 1  # keep going outwards if value greater than cutoff value
            else:
                radius = i - 1  # stop at threshold and record radius of values
                rad_bg = i + 1

                break
    print(radius)
    is0 = False # initialise is0 trigger: ignore galaxy if there is a zero value in it, it is a galaxy at the border of the image
    if radius > 2:  # Ensuring we only count the galaxy if it has a radius larger than 2, as a lower radius likely indicates noise.

        raditer = rad_bg  # initialise a radius value to iterate over
        while raditer >= (-1) * rad_bg:  # circle finding, loop over x and y coords

            xi = raditer  # initialise xi as distance along axis relative to x
            yi = int(np.sqrt(rad_bg ** 2 - raditer ** 2))  # initialise yi as maximum "height" within circle

            while rad_bg ** 2 >= xi ** 2 + yi ** 2:  # scan downwards along y axis at x = x+xi, mask at each point

                if array.shape[0] > y + yi and array.shape[1] > x + xi and radius ** 2 >= xi ** 2 + yi ** 2:
                    if arraydata[y+yi][x+xi] == 0:
                        is0 = True
                    values.append(array[y + yi][x + xi])
                    where.append((x + xi, y + yi))
                    array = mask_value(array, (y + yi, x + xi))
                    flux += arraydata[y + yi][x + xi]  # sums even if there's an overlap with another galaxy (for ease
                    yi -= 1

                elif radius ** 2 < xi ** 2 + yi ** 2 and array.shape[0] > y + yi and array.shape[1] > x + xi and mask[y + yi][x + xi] == False:

                    bg_vals.append(array[y + yi][x + xi])

                    # array = mask_value(array, (y+yi,x+xi))
                    yi -= 1

                else:  # If out of bounds, keep scanning downwards
                    yi -= 1

            raditer -= 1
        if is0:
            return None, None, None, None, array
        else:
            return values, where, flux, bg_vals, array

    elif radius <= 2:  # mask out all galaxies with a radius smaller than or equal to 2

        raditer = radius  # initialise a radius value to iterate over

        while raditer >= radius * (-1):  # circle finding, loop over x and y coords

            xi = raditer  # initialise xi as distance along axis relative to x
            yi = int(np.sqrt(radius ** 2 - raditer ** 2))  # initialise yi as maximum "height" within circle

            while radius ** 2 >= xi ** 2 + yi ** 2:  # scan downwards along y axis at x = x+xi, mask at each point

                if array.shape[0] > y + yi and array.shape[1] > x + xi:
                    array = mask_value(array, (y + yi, x + xi))
                    yi -= 1
                else:
                    yi -= 1

            raditer -= 1

        return None, None, None, None, array


def var_aperture(array, source_lim, rad_lim, centered=False):
    """
    find brightest pixel values down to n, for each pixel value finds a "circular" region of light
    and masks the entire region which i will call a galaxy
    :param array: 2d array to be analysed
    :param n: cutoff value below which a pixel is not counted as a source
    :param m: cutoff value below which a pixel is counted as background
    :param centered: return the center coordinates of the galaxy

    :return: max_vals: 2d array containing pixel values of each galaxy
             where: 2d array containing tuples containing coordinates in (x,y) indices of each pixel in each galaxy
             fluxes: 1d array containing summed flux values of each galaxy
    """
    i = True
    max_vals = []
    fluxes = []
    centers = []  # measure the center of each galaxy
    where = []  # coordinates of pixels in each galaxy
    while i:
        maxval = np.amax(array)
        print(maxval)
        if maxval <= source_lim:
            break

        else:
            where1 = np.argmax(array)  # returns index in flattened arraycopy for first occurrence of maxval
            where2 = np.unravel_index(where1, array.shape)  # back to a 2d coord
            print(where2)

            values, where3, lightsum, bg_values, array = findradiusandmask(array, (where2[1], where2[0]), rad_lim)

            if values == None:
                continue

            else:
                bg_av = np.median(bg_values)
                values = [e - bg_av for e in values]
                print(lightsum - len(values) * bg_av)
                fluxes.append(lightsum - len(values) * bg_av)
                centers.append(where2)
                where.append(where3)
                max_vals.append(values)

    fluxes.sort()
    if centered == False:
        return max_vals, where, fluxes, array

    else:
        return max_vals, where, centers, array


starcoords = [[(2161,3812),(2103,3710)],
              [(2445,3441),(2484,3384)],
              [(2079,1452),(2097,1405)],
              [(2064,1449),(2113,1382)],
              [(2105,2335),(2158,2284)],
              [(2153,3348),(2313,3231)],
              [(1369,3283),(1513,3141)],
              [(1380,3165),(1462,2955)],
              [(1421,2967),(1454,0)],
              [(1176,446),(1607,425)],
              [(1463,488),(1399,144)],
              [(1077,340),(1716,306)],
              [(2427,417),(2569,0)],
              [(2569,4610),(2479,417)],
              [(721, 3417),(832,3194)],
              [(852, 2361),(952,2206)],
              [(925, 2833),(1026,2694)],
              [(530, 4128),(597,4061)], [(1462,225),(1471,217)], [(1640,355),(1646, 340)],
              [(1425, 4020),(1492,3997)], [(1466,343), (1463, 340) ], [(1389,241),(1477,229)],
              [(1415, 4506), (1474, 3450)], [(1080,315),(1017,314)], [(1103,427),(1179,425)],
              [(0, 4610), (137,0)],[(2438,3446), (2518, 3354)],[(1024,453),(1044,423)],
              [(0,140), (2569, 0)],[(1389, 1810),(1443, 1753)], [(1677,448), (1597,416)],
              [(1380, 3555),(1470, 3308)], [(1210, 3380), (1657, 3008)], [(1297, 151), (1551, 94)],
              [(2099, 4610), (2569, 4388)], [(0, 4610), (2569, 4499)]]
