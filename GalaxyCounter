def rectanglecoord (array, function, uppercorner, lowercorner):
    """
    applies function to all coordinates in rectangle
    :param function: any function
    :param uppercorner: corner on top [larger y], expect an (x,y) format (x,y, indices)
    :param lowercorner: oorner on bottom [smaller y], expect an (x,y) format (x,y indices)
    :return: array with function applied to relevant portions
    """
    xu = uppercorner[0]
    xd = lowercorner[0]
    yu = uppercorner[1]
    yd = lowercorner[1]
    if xu <= xd:
        for j in range(yu - yd + 1):
            for i in range(xd - xu + 1):
                array = function(array, [ yu - j , xu + i ])

    elif xu > xd:
        for j in range(yu - yd + 1):
            for i in range(xu - xd + 1):
                array = function(array, [ yu - j , xd + i ])

    return array


def mask_value(arr, coords):
    '''
    Function masks one value in a 2d array given its cooredinates
    Args:
        arr:: 2d masked array
        coords: list
            coordinates of value that are to be masked
            
    Returns:
        arr:: ma array
            masked array with value masked
    '''
    arr = ma.array(arr)
    arr[coords[0], coords[1]] = ma.masked
    
    return arr
    

def fixed_aperature(data, bg_lim, mask_size):
    '''
    Counts galaxies using a fixed aperature
    Args:
        data:: array
        bg_lim:: int
            brightness limit for when function stops counting object as a galaxy
        mask_size:: int
            Length of the fixed aperature mask in pixel values (square mask)
    Returns:
        source_coords: list
            Coordinates of the galaxies
        brightness_vals: list
            list of the brightest pixel in each source.
    '''
    datacopy = data.copy()
    source_coords = []
    brightness_vals = []
    
    while np.amax(datacopy) > bg_lim:
        
        brightness_vals.append(np.amax(datacopy))
        coords1 = np.argmax(datacopy)
        coords2 = np.unravel_index(coords1, datacopy.shape) #2d coordinate of the brightest pixel
        
        source_coords.append(coords2)
        upp_corner = [coords2[1]+mask_size, coords2[0] + mask_size] # coords2[1] used first as the first index corresponds to the x value
        low_corner = [coords2[1]-mask_size, coords2[0] - mask_size]
        datacopy = rectanglecoord(datacopy, mask_value, upp_corner, low_corner)
        print(np.amax(datacopy))
        #print(np.amax(datacopy))
        
    return source_coords, brightness_vals

def findradiusandmask(array, coordinate, cutoff = 0):
    """
    finds radius of galaxy and masks
    :param array: 2D array of data
    :param coordinate: tuple of form (x,y) x,y indices of array
    :param cutoff: value at which you decide a pixel is background noise
    :return: returns an array containing the pixel values within the galaxy, and the coordinates making
            up the circle of the galaxy
    """
    x = coordinate[0]
    y = coordinate[1]
    center = array[y][x]
    values = []
    where = []
    i = 1 #initialise i for the loop
    while True: #radius finding
        if array.shape[0] > y+i:
            if array[y + i][x] > cutoff:
                i += 1 #keep going outwards if value greater than cutoff value
            else:
                radius = i - 1 #stop at threshold and record radius of values
                break

        else:
            if array[y - i][x] > cutoff:        #if going up gets out of bounds, go down
                i += 1 #keep going outwards if value greater than cutoff value
            else:
                radius = i - 1 #stop at threshold and record radius of values
                break


    raditer = radius  # initialise a radius value to iterate over
    while raditer >= radius*(-1): #circle finding, loop over x and y coords
        xi = raditer #initialise xi as distance along axis relative to x
        yi = int(sp.sqrt(radius**2 - raditer**2)) #initialise yi as maximum "height" within circle

        while radius**2 >= xi**2 + yi**2: #scan downwards along y axis at x = x+xi, mask at each point
            if array.shape[0] > y+yi and array.shape[1] > x+xi:
                values.append(array[y + yi][x + xi])
                where.append((x+xi,y+yi))
                array = mask_value(array, (y+yi,x+xi))
                yi -= 1
            else:
                yi -= 1


        raditer -= 1

    return values, where, array
    
   def findbrightestminandmaskgalaxy (array, n):
    """
    find brightest pixel values down to n, for each pixel value finds a "circular" region of light 
    and masks the entire region which i will call a galaxy
    :param array: 2d array to be analysed
    :param n: cutoff value below which a pixel is not counted as a source
    :return: max: 2d array containing pixel values of each galaxy
             where: 2d array containing tuples containing coordinates in (x,y) indices of each pixel in each galaxy
    """
    i = True
    max = []
    where = []
    while i:
        maxval = sp.amax(array)
        if maxval <= n:
            break
        else:
            where1 = sp.argmax(array) #returns index in flattened arraycopy for first occurrence of maxval
            where2 = sp.unravel_index(where1, array.shape) #back to a 2d coord
            values, where3, array  = findradiusandmask(array, (where2[1],where2[0]), n )
            where.append(where3)
            max.append(values)
    return max, where
