from astropy.io import fits
import numpy as np
import matplotlib.pyplot as plt
import numpy.ma as ma
from astropy.visualization import ZScaleInterval
from astropy.nddata import CCDData

scan_results = var_aperture(maskeddata, 3480, 3443)

flux_vals = scan_results[2]

flux_vals.sort()

# Finidng the magnitudes using the counts and the flux calibration 
header = hdulist[0].header
magnitudes = header["magzpt"] + (-1 * 2.5) * np.log10(flux_vals)

# Using the tally to find the total number of galaxies found and how many are
# found for each specific magnitude 
fluxfreq = tally(magnitudes)
total = sum(fluxfreq.values())

# Generating the plot with all the datapoints
nm = []
mpix = []

for i in fluxfreq:
    total -= fluxfreq[i]
    nm.append(total)
    mpix.append(i)
    
nm = np.log10(nm)

# Omitting the last value, as this is -infinity
plt.scatter(mpix[1000:-20], nm[1000:-20], label = 'all data points plotted using variable aperature galaxy counter')  
z = np.polyfit(mpix[1000:-20], nm[1000:-20], 1)

mpix_y = [e * z[0] for e in mpix]

plt.plot(mpix[1000:-20] ,  mpix_y[1000:-20] + z[1], color='k', \
         label = 'Linear plot with gradient = '+str(round(z[0],2)))
    
plt.xlabel('Magnitude')
plt.ylabel('$Log_{10}$N(m)')
plt.legend()
plt.grid()

#%%

# Binning the values by plotting an average for separately binned m values
m_vals, data = [mpix[976:-20], nm[976:-20]]


def find_index(m_low, m_high):
    '''
    Args:
        m_low::float
        m_high::float
            The lower and higher limits of the magnitude bin.
    Returns:
        j::float
        h::float
            The corresponding indices the edges of the bins refers to.
    '''
    j = 0
    h = len(m_vals) - 1
    
    if m_low <= m_vals[len(m_vals)-1]:
        j = len(m_vals)-1
    else:
        while m_vals[j] >= m_low: 
            j += 1
    
    if m_high >= m_vals[0]:
        h = 0 
    else:
        while  m_vals[h] <= m_high:
            h -= 1

    return j, h
    

m_binned = []
vals_binned=[]

# binning values
for i in np.arange(10.5, 17.5, 0.5):
    upper, lower = find_index(i, i+0.5)
    m_binned.append((2*i + 0.5)/2)

    print(lower,upper)
    vals_binned.append(np.mean(data[lower:upper]))
    

plt.scatter(m_binned, vals_binned, label='Binned data points from scanning full image', marker='x')

# Extracting the values before the gradient begins to flatten due to all the
# galaxies being counted     
z = np.polyfit(m_binned[0:8], vals_binned[0:8], 1)


y_vals = [e * z[0] for e in m_binned]

plt.plot(m_binned ,  y_vals + z[1], color='k', \
         label = 'Linear plot with gradient = '+str(round(z[0],2)))
plt.xlabel('Magnitude')
plt.ylabel('$Log_{10}$N(m)')
plt.legend()
plt.grid()
